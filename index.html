<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Router & OSPF Practice Test</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 20px;
      background-color: #f4f7f6;
      color: #333;
      line-height: 1.6;
    }
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 30px;
      font-size: 2.2em;
      font-weight: 600;
    }
    #welcome-page {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 80vh;
      background-color: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      padding: 30px;
      max-width: 700px;
      margin: auto;
    }
    .action-button {
      background-color: #007bff;
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
    }
    .action-button:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }
    #quiz-container {
      max-width: 900px;
      margin: 20px auto;
      padding: 25px;
      background-color: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      display: none;
    }
    .question {
      margin-bottom: 25px;
      border: 1px solid #e0e0e0;
      padding: 20px;
      border-radius: 10px;
      background-color: #fefefe;
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    .question:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }
    .options label {
      display: block;
      margin-bottom: 10px;
      padding: 12px 15px;
      background-color: #f0f5f8;
      border: 1px solid #d3e0ea;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }
    .options input[type="radio"] {
      margin-right: 10px;
      accent-color: #007bff;
    }
    .feedback {
      margin-top: 15px;
      font-weight: bold;
      padding: 10px 15px;
      border-radius: 8px;
    }
    .correct {
      color: #1a7a1a;
      background-color: #e6ffe6;
      border: 1px solid #66cc66;
    }
    .incorrect {
      color: #cc3300;
      background-color: #ffe6e6;
      border: 1px solid #ff6666;
    }
    .explanation {
      margin-top: 15px;
      padding: 15px;
      background-color: #e9f0f5;
      border-left: 5px solid #007bff;
      border-radius: 8px;
      font-size: 0.95em;
      color: #555;
    }
    #timer-container {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #ffffff;
      padding: 10px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      z-index: 1000;
      display: none; /* Hidden by default */
    }
    #timer-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #007bff;
      margin-bottom: 5px;
    }
    #progress-bar-container {
      width: 100%;
      background-color: #e0e0e0;
      height: 8px;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 5px;
    }
    #progress-bar {
      height: 100%;
      width: 100%;
      background-color: #28a745;
      transition: width 1s linear;
    }
    #progress-bar.warning { background-color: #ffc107; }
    #progress-bar.danger { background-color: #dc3545; }
    #submit-button-container {
      text-align: center;
      margin-top: 40px;
      display: none; /* Hidden by default */
    }
    #results-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      display: none; /* Hidden by default */
    }
    #results-box {
      background-color: #ffffff;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
      text-align: center;
      max-width: 500px;
      width: 90%;
    }
    #results-box h3 {
      font-size: 2em;
      color: #2c3e50;
      margin-bottom: 15px;
    }
    #results-box p {
      font-size: 1.2em;
      color: #555;
      margin-bottom: 10px;
    }
    .pass { color: #28a745; font-weight: bold; }
    .fail { color: #dc3545; font-weight: bold; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="welcome-page">
  <h1>Welcome to Router & OSPF Practice Test</h1>
  <p>This test will help you prepare for the Quiz 2.</p>
  <p>You will have <strong>60 minutes</strong> to complete <strong>45 questions</strong>.</p>
  <button id="start-button" class="action-button">START</button>
</div>

<div id="timer-container">
  <div id="timer-display">60:00</div>
  <div id="progress-bar-container">
    <div id="progress-bar"></div>
  </div>
</div>

<h1 style="display: none;" id="quiz-title">Router & OSPF Practice Test</h1>

<div id="quiz-container"></div>

<div id="submit-button-container">
  <button id="submit-test-button" class="action-button">Submit Test</button>
</div>

<div id="results-overlay">
  <div id="results-box">
    <h3>Test Results</h3>
    <p>You scored: <span id="final-score"></span> / <span id="total-questions-display"></span></p>
    <p id="pass-fail-message"></p>
    <button class="action-button" onclick="location.reload()">Retake Test</button>
  </div>
</div>

<script>
  // --- Global Variable Declarations ---
  var questions; // Will hold the shuffled and filtered questions
  var timeLeft = 60 * 60; // 60 minutes in seconds
  var timerInterval;
  var passingPercentage = 0.65; // 65% passing requirement
  
  // --- Original Questions (from Question1.txt with corrected answers as full text) ---
  const originalQuestions = [
    // Section A: Multiple Choice Questions (30 Questions)
    {
      question: "Which two steps occur on a router when it receives an IP packet? (Choose two.)",
      options: ["Checks the destination MAC address against its MAC address table.", "De-encapsulates the packet from the Data Link Layer frame.", "Matches the destination IP address against its routing table.", "Assigns a new Layer 4 port number."],
      answer: "De-encapsulates the packet from the Data Link Layer frame.", 
      explanation: "Routers de-encapsulate packets and use their routing table to determine where to send them. MAC address checking is done by switches. Assigning Layer 4 ports is typically a host or server function.<br><i>Reference: Ch. 16, Ch. 17</i>"
    },
    {
      question: "What is the primary purpose of a routing protocol like OSPF?",
      options: ["To encapsulate packets for transmission across the network.", "To discover and learn routes automatically from other routers.", "To assign IP addresses to hosts dynamically.", "To filter traffic based on security policies."],
      answer: "To discover and learn routes automatically from other routers.",
      explanation: "Dynamic routing protocols like OSPF automate the process of discovering networks and learning routes from other routers. Encapsulation and address assignment are handled by other protocols/layers. Filtering is a security function, often separate.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "A network engineer configures a static route on Router R1: ip route 10.10.0.0 255.255.0.0 192.168.1.2. What type of route is this?",
      options: ["Default Route", "Host Route", "Network Route", "Floating Static Route"],
      answer: "Network Route",
      explanation: "This route specifies a destination network (10.10.0.0/16) and a next-hop address (192.168.1.2), making it a Network Route. A default route uses 0.0.0.0/0. A host route uses a /32 mask for a single host. A floating static has an AD higher than the default.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "In the show ip route output, what does the routing protocol code 'C' represent?",
      options: ["Connected", "Configured Static", "Candidate Default", "Cisco Discovery Protocol"],
      answer: "Connected",
      explanation: "The code 'C' in show ip route explicitly indicates a Connected route, meaning a route to a subnet directly attached to one of the router's active interfaces. Other codes represent different route types.<br><i>Reference: Chapter 16-20.pdf, pg. 10</i>"
    },
    {
      question: "Which OSPF packet type is primarily used to establish and maintain neighbor adjacencies?",
      options: ["Database Description (DBD)", "Link-State Request (LSR)", "Hello", "Link-State Update (LSU)"],
      answer: "Hello",
      explanation: "OSPF Hello packets are sent periodically to discover neighbors and maintain adjacency relationships. Other packet types are used during the database synchronization process after adjacency is established.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What is the default administrative distance for an OSPF internal route?",
      options: ["1", "90", "110", "120"],
      answer: "110",
      explanation: "The default administrative distance for OSPF internal routes is 110. Connected routes are 0, EIGRP is 90, and RIP is 120.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "Refer to the topology: R1 (RID 1.1.1.1) and R2 (RID 2.2.2.2) are connected via a FastEthernet link. R1's Fa0/0 has IP 192.168.10.1/24, and R2's Fa0/0 has 192.168.10.2/24. Which command on R1 would correctly start the OSPF process and assign it a process ID of 100?",
      options: ["router ospf 100", "router ospf", "enable ospf 100", "ip ospf 100 area 0"],
      answer: "router ospf 100",
      explanation: "The command to initiate the OSPF process configuration mode is router ospf process-id.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "When configuring single-area OSPF, what is the primary function of the network command?",
      options: ["To statically assign IP addresses to interfaces.", "To specify which interfaces participate in OSPF and their area membership.", "To define the OSPF router ID.", "To configure the OSPF hello and dead intervals."],
      answer: "To specify which interfaces participate in OSPF and their area membership.",
      explanation: "The network command tells OSPF which of the router's interfaces should participate in the protocol and assigns them to a specific area. It doesn't assign addresses, define the RID, or set timers directly.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "A packet arrives at a router with a destination IP address of 192.168.5.10. The routing table contains the following entries:<br>• O 192.168.5.0/24 [110/20] via 10.1.1.2<br>• S 192.168.0.0/16 [1/0] via 10.2.2.2<br>• C 10.1.1.0/24 is directly connected, Gi0/0 <br>Which route will the router use to forward the packet?",
      options: ["The OSPF route (192.168.5.0/24)", "The Static route (192.168.0.0/16)", "The Connected route (10.1.1.0/24)", "None, it will be dropped"],
      answer: "The OSPF route (192.168.5.0/24)",
      explanation: "The Longest Prefix Match rule dictates that the most specific route is chosen. The /24 route is more specific than the /16 static route for the destination 192.168.5.10. The connected route doesn't match the destination. Therefore, the OSPF /24 route is used.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "Which OSPF LSA type is flooded only within a single area and describes the links of a router?",
      options: ["Type 1 (Router LSA)", "Type 2 (Network LSA)", "Type 3 (Summary LSA)", "Type 5 (External LSA)"],
      answer: "Type 1 (Router LSA)",
      explanation: "Type 1 LSAs (Router LSAs) are generated by each router to describe its own links and are flooded only within the area where the router resides. Type 2 is for DRs describing multi-access networks. Type 3 is for inter-area summaries. Type 5 is for external routes, flooded throughout the AS (except stub areas).<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What is the primary factor OSPF uses to calculate the cost of an interface?",
      options: ["Delay", "Reliability", "Bandwidth", "Load"],
      answer: "Bandwidth",
      explanation: "OSPF's primary metric for calculating interface cost is based on Bandwidth. The default formula is Reference_BW / Interface_BW. Delay, Reliability, and Load are factors in EIGRP's metric calculation.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "A network administrator wants to ensure Router R1 (RID 1.1.1.1) always uses 1.1.1.1 as its OSPF Router ID. Which command should be used within the OSPF process configuration?",
      options: ["router-id 1.1.1.1", "ip ospf router-id 1.1.1.1", "set router-id 1.1.1.1", "ospf router-id 1.1.1.1"],
      answer: "router-id 1.1.1.1",
      explanation: "To manually set the OSPF Router ID, the command router-id <ip-address> is used within the OSPF process configuration mode. The other options are not valid IOS commands for this purpose.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "In a multiarea OSPF design, what is the significance of Area 0?",
      options: ["It is the area with the highest number of routers.", "It is the area used for external route summarization.", "It is the backbone area to which all other areas must connect.", "It is the area with the lowest OSPF cost."],
      answer: "It is the backbone area to which all other areas must connect.",
      explanation: "Area 0 is defined as the OSPF backbone area. All other areas must connect directly to Area 0 to ensure proper routing information flow across the OSPF domain. The number of routers, summarization, or cost does not define Area 0's primary role.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What is the primary purpose of the Designated Router (DR) in OSPF on a multi-access network like Ethernet?",
      options: ["To act as the default gateway for all hosts on the segment.", "To reduce the number of adjacencies formed, simplifying database synchronization.", "To authenticate OSPF packets.", "To prevent routing loops."],
      answer: "To reduce the number of adjacencies formed, simplifying database synchronization.",
      explanation: "On multi-access networks like Ethernet, the DR/BDR mechanism reduces the number of full OSPF adjacencies required. Instead of every router forming an adjacency with every other router, routers only form full adjacencies with the DR and BDR. The DR is not a default gateway, does not authenticate packets, and OSPF itself prevents loops via its algorithm.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "A router needs to send a packet to the network 172.16.0.0/16. Its routing table contains the following routes:<br>• S 172.16.0.0/16 [1/0] via 10.1.1.1<br>• O 172.16.0.0/24 [110/15] via 10.2.2.2<br>• S* 0.0.0.0/0 [1/0] via 10.3.3.3 Which route will be used?",
      options: ["The Static route (172.16.0.0/16)", "The OSPF route (172.16.0.0/24)", "The Default route (0.0.0.0/0)", "It depends on the packet's source address."],
      answer: "The Static route (172.16.0.0/16)",
      explanation: "Again, the Longest Prefix Match applies. The static route for 172.16.0.0/16 is more specific than the OSPF summary route for 172.16.0.0/24 and is therefore preferred over both the /24 route and the default route for any destination within the 172.16.0.0/16 range.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "What is the default OSPF network type for an Ethernet interface?",
      options: ["Point-to-Point", "Broadcast", "Non-Broadcast Multi-Access (NBMA)", "Point-to-Multipoint"],
      answer: "Broadcast",
      explanation: "The default OSPF network type for Ethernet interfaces is Broadcast. This setting enables the DR/BDR election process. Point-to-Point is for direct links. NBMA is for Frame Relay-like networks. Point-to-Multipoint is a manual configuration for specific NBMA scenarios.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What is the correct sequence of OSPF RID selection if no router-id command is explicitly configured?",
      options: ["Highest active physical interface IP, then highest active loopback IP.", "Highest active loopback IP, then highest active physical interface IP.", "Lowest active loopback IP, then lowest active physical interface IP.", "Router's MAC address."],
      answer: "Highest active loopback IP, then highest active physical interface IP.",
      explanation: "If not manually set, OSPF selects the Router ID by first looking for active loopback interfaces and choosing the highest IP address among them. If no loopbacks are available, it then chooses the highest IP address from active physical interfaces.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "A network engineer wants to advertise a default route into an OSPF domain from Router R1, which has a static default route configured. Which command should be used in the OSPF process?",
      options: ["default-information originate", "redistribute static", "ip route 0.0.0.0 0.0.0.0", "network 0.0.0.0 0.0.0.0 area 0"],
      answer: "default-information originate",
      explanation: "The command default-information originate, used within the OSPF process configuration, tells the router to advertise a default route (0.0.0.0/0) into the OSPF domain. It often requires a static default route to exist on the router first.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "What command would you use to verify the OSPF cost configured on a specific interface (e.g., GigabitEthernet0/1)?",
      options: ["show ip ospf", "show ip protocols", "show ip ospf interface brief", "show running-config interface GigabitEthernet0/1"],
      answer: "show ip ospf interface brief",
      explanation: "The show ip ospf interface brief command provides a quick overview of OSPF-enabled interfaces, including their IP addresses, area, state, and cost. show ip ospf gives general process info. show ip protocols shows routing protocol configuration summary. show run int shows the configuration but might not display the effective cost calculated by OSPF.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "In the show ip route output, what does the metric value represent for an OSPF route (e.g., [110/15])?",
      options: ["Administrative Distance / Hop Count", "Administrative Distance / OSPF Cost", "Hop Count / Bandwidth", "Reliability / Load"],
      answer: "Administrative Distance / OSPF Cost",
      explanation: "In the routing table output, the metric for OSPF routes is shown as [Administrative Distance / OSPF Cost]. For example, [110/15] means AD is 110, and the total OSPF cost to the destination is 15.<br><i>Reference: Chapter 16-20.pdf</i>"
    },
    {
      question: "Consider the network command: network 172.16.0.0 0.0.255.255 area 1. Which interface IP address would match this command?",
      options: ["172.16.1.1 255.255.255.0", "192.168.10.1 255.255.255.0", "10.1.1.1 255.255.255.0", "172.16.200.50 255.255.0.0"],
      answer: "172.16.200.50 255.255.0.0",
      explanation: "The wildcard mask 0.0.255.255 means the first two octets (172.16) must match exactly, but the last two octets can be anything. The IP 172.16.200.50 matches this pattern. IP 172.16.1.1 also matches the first two octets, but its mask /24 implies the third octet must also match, which isn't required by the wildcard mask given. IPs in different subnets like 192.168.x.x or 10.x.x.x don't match the 172.16 prefix.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "What is the primary benefit of dividing a large OSPF network into multiple areas?",
      options: ["Increases the number of routers that can be supported.", "Reduces the size of routing tables and the LSDB on internal routers.", "Allows the use of different routing protocols in different areas.", "Automatically configures all static routes."],
      answer: "Reduces the size of routing tables and the LSDB on internal routers.",
      explanation: "The main advantage of multiarea OSPF is to contain Link-State Advertisement (LSA) flooding and reduce the size of the LSDB and routing tables on routers that are internal to an area. It doesn't inherently increase router capacity, require different protocols, or auto-configure static routes.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "A static route configured with an administrative distance higher than the default for that route type is known as what?",
      options: ["Default Route", "Host Route", "Floating Static Route", "Summary Route"],
      answer: "Floating Static Route",
      explanation: "A Floating Static Route is a static route configured with an AD higher than the default for that route type. This makes it a backup route, only installed in the routing table if the primary route (with a lower AD) is lost.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "In OSPF, what is the term for a router that has interfaces in multiple areas, including the backbone area?",
      options: ["Internal Router", "Autonomous System Boundary Router (ASBR)", "Area Border Router (ABR)", "Backbone Router"],
      answer: "Area Border Router (ABR)",
      explanation: "An Area Border Router (ABR) is defined as a router with interfaces connected to multiple OSPF areas, at least one of which must be the backbone area (Area 0). An Internal Router has all interfaces in one area. An ASBR connects to another AS. 'Backbone Router' isn't a standard OSPF term for a specific router type.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What happens when the OSPF Dead Interval expires for a neighbor?",
      options: ["The DR is re-elected.", "The neighbor relationship is reset.", "The interface cost is recalculated.", "A new Router ID is selected."],
      answer: "The neighbor relationship is reset.",
      explanation: "If a router stops receiving Hello packets from a neighbor before the Dead Interval timer expires, that neighbor is considered down, and the adjacency relationship is reset or dropped. This triggers SPF calculations and routing table updates. DR election happens under different conditions. Cost recalculation happens due to bandwidth changes. RID selection happens at boot/process start.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "What is the purpose of the passive-interface command in OSPF?",
      options: ["To prevent an interface from sending data packets.", "To prevent an interface from forming OSPF adjacencies while still advertising its network.", "To shut down the interface.", "To make the interface only send Hello packets."],
      answer: "To prevent an interface from forming OSPF adjacencies while still advertising its network.",
      explanation: "The passive-interface command prevents an OSPF-enabled interface from sending Hello packets and forming adjacencies. However, the network connected to that interface is still advertised by the router via Type 1 or Type 3 LSAs. It doesn't shut the interface or limit it to Hellos only. It's often used on LAN segments connected to end devices.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "Which command directly modifies the calculated OSPF cost of an interface?",
      options: ["bandwidth kilobits", "ip ospf cost value", "clock rate", "speed Mbps"],
      answer: "ip ospf cost value",
      explanation: "The interface subcommand ip ospf cost <value> directly sets the OSPF cost for that specific interface, overriding the default calculation based on bandwidth. Changing bandwidth affects the calculated cost. clock rate and speed relate to physical layer settings, not the OSPF metric directly.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "What does the 'L' code signify in the show ip route output legend?",
      options: ["Local route", "Link-state route", "Learned route", "Loopback route"],
      answer: "Local route",
      explanation: "The 'L' code in the show ip route output stands for Local route. These are host routes (/32) for the router's own interface IP addresses.<br><i>Reference: Chapter 16-20.pdf</i>"
    },
    {
      question: "Which of the following is NOT a characteristic used by routers to make a forwarding decision based on the routing table?",
      options: ["Prefix (Subnet ID)", "Network Mask", "Next Hop", "Source MAC Address"],
      answer: "Source MAC Address",
      explanation: "Routers make Layer 3 forwarding decisions based on the destination IP address and information in their routing table, specifically the Prefix, Mask, and Next Hop. The Source MAC Address is relevant for Layer 2 switching but not for the router's IP routing decision.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "An OSPF router receives two paths to the same destination network: Path A with a total cost of 50 and Path B with a total cost of 50. What will OSPF do?",
      options: ["Choose Path A only.", "Choose Path B only.", "Load balance across both paths (if equal-cost multi-path is enabled).", "Drop the packets."],
      answer: "Load balance across both paths (if equal-cost multi-path is enabled).",
      explanation: "OSPF supports Equal-Cost Multi-Path (ECMP) routing. If two or more paths to a destination have the exact same total OSPF cost, OSPF can load balance traffic across those paths, distributing the load (assuming the platform supports it). It doesn't arbitrarily pick one path or drop packets in this scenario.<br><i>Reference: Ch. 19</i>"
    },

    // Section B: True/False Questions (15 Questions)
    {
      question: "T/F: A router makes its forwarding decision based primarily on the destination MAC address found in the incoming frame header.",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. Routers make forwarding decisions based on the destination IP address in the packet header (Layer 3), consulting their routing table. Switches use the destination MAC address (Layer 2) for forwarding.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "T/F: Static routes must always be manually reconfigured if the network topology changes.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. Static routes are manually configured and do not automatically adapt to network changes. If a link fails, the static route remains in the table potentially causing black holes unless manually removed or adjusted.<br><i>Reference: Ch. 16</i>"
    },
    {
      question: "T/F: The OSPF Router ID must always be configured manually; it cannot be chosen automatically.",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. While the router-id command allows manual configuration, OSPF can automatically select a Router ID based on the highest active loopback IP, or if none, the highest active physical interface IP.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: In a single-area OSPF network, all routers have identical Link-State Databases (LSDBs).",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. In a correctly functioning single-area OSPF network, all routers within that area maintain identical LSDBs, as they flood all Link-State Advertisements to each other.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: The network command in OSPF is used to advertise external routes into the OSPF domain.",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. The network command tells OSPF which local interfaces should participate in OSPF and belong to which area. Advertising external routes typically involves redistribution commands or specific features like default-information originate.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: OSPF uses the Dijkstra Shortest Path First (SPF) algorithm to calculate the best paths.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. OSPF uses the Dijkstra algorithm, also known as Shortest Path First (SPF), to calculate the shortest path tree from the router's perspective based on the LSDB.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "T/F: The Administrative Distance is used by a router to select the best path among routes learned from the same routing protocol .",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. Administrative Distance (AD) is used to select the best path among routes learned from different routing protocols (e.g., choosing OSPF over RIP). The Metric is used to select the best path within the same routing protocol (e.g., choosing the lower cost OSPF path).<br><i>Reference: Chapter 16-20.pdf</i>"
    },
    {
      question: "T/F: A Type 5 LSA in OSPF describes routes external to the OSPF autonomous system.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. Type 5 LSAs (AS External LSAs) are generated by ASBRs to describe routes that originate from outside the OSPF autonomous system.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "T/F: OSPF Hello packets are sent using the multicast address 224.0.0.5.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. OSPF Hello packets are multicast to the address 224.0.0.5, which is the \"All OSPF Routers\" multicast address.<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "T/F: The \"Gateway of last resort\" in the show ip route output refers to the default route.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. The \"Gateway of last resort\" line in the show ip route output explicitly points to the default route (0.0.0.0/0) used when no other specific route matches the destination.<br><i>Reference: Chapter 16-20.pdf</i>"
    },
    {
      question: "T/F: OSPF calculates the cost of an interface inversely proportional to its bandwidth; faster interfaces have lower costs.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. OSPF's cost calculation (Cost = Reference_BW / Interface_BW) means that as bandwidth increases, the calculated cost decreases. This makes faster links more preferable in the routing path.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: In OSPF, a router can be both an ABR and an ASBR simultaneously.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. A router can simultaneously connect to multiple OSPF areas (making it an ABR) and also have a connection to an external network (making it an ASBR).<br><i>Reference: Ch. 19</i>"
    },
    {
      question: "T/F: The ip ospf cost command overrides the default OSPF cost calculation based on bandwidth.",
      options: ["True", "False"],
      answer: "True",
      explanation: "TRUE. The ip ospf cost <value> interface command directly sets the cost for that interface, overriding the value calculated by the auto-cost reference-bandwidth and interface bandwidth settings.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: The wildcard mask 0.0.0.0 used with the OSPF network command means 'ignore all bits' when matching interfaces.",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. The wildcard mask 0.0.0.0 means \"compare all bits\" or \"exact match\". It requires the network address specified in the network command to match the interface IP address exactly.<br><i>Reference: Ch. 20</i>"
    },
    {
      question: "T/F: OSPF is classified as an Exterior Gateway Protocol (EGP).",
      options: ["True", "False"],
      answer: "False",
      explanation: "FALSE. OSPF is an Interior Gateway Protocol (IGP), used within a single autonomous system. Exterior Gateway Protocols (EGPs) like BGP are used for routing between different autonomous systems.<br><i>Reference: Ch. 19</i>"
    }
  ];

  // --- Quiz Logic Functions ---

  // Function to shuffle an array (Fisher-Yates algorithm)
  function shuffleArray(array) {
    // Create a copy to avoid modifying the original array reference during shuffling
    var shuffledArray = array.slice(); 
    for (var i = shuffledArray.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]]; // Swap elements
    }
    return shuffledArray;
  }

  // Initialize quiz (renders questions to the DOM)
  function initializeQuiz() {
    var quizContainer = document.getElementById('quiz-container');
    quizContainer.innerHTML = ''; // Clear previous questions if any

    // This section prepares the 'questions' array by filtering and shuffling.
    // It's called once when the quiz starts (via startButton click).
    var mc = originalQuestions.filter(function(q) { return q.options.length > 2; });
    var tf = originalQuestions.filter(function(q) { return q.options.length === 2 && (q.options.includes("True") || q.options.includes("False")); });
    
    // Shuffle each group independently
    var shuffledMc = shuffleArray(mc);
    var shuffledTf = shuffleArray(tf);

    // Combine the shuffled groups to form the final 'questions' array
    questions = [...shuffledMc, ...shuffledTf];

    // Shuffle options for each question, but skip for True/False questions
    questions.forEach(function(q) {
      var isTrueFalseQuestion = q.options.length === 2 &&
                                ((q.options[0] === "True" && q.options[1] === "False") ||
                                 (q.options[0] === "False" && q.options[1] === "True"));

      if (!isTrueFalseQuestion) {
        // Only shuffle options that are NOT True/False
        q.options = shuffleArray(q.options); 
      }
    });


    // Render questions to the DOM based on the now-populated 'questions' array
    questions.forEach(function(q, index) {
      var questionDiv = document.createElement('div');
      questionDiv.classList.add('question');

      questionDiv.innerHTML = '<p>' + (index + 1) + '. ' + q.question + '</p>';

      var optionsDiv = document.createElement('div');
      optionsDiv.classList.add('options');

      q.options.forEach(function(option) {
        var label = document.createElement('label');
        var radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'question' + index;
        radio.value = option;
        radio.addEventListener('change', function() { checkAnswer(index, option); });
        label.appendChild(radio);
        label.appendChild(document.createTextNode(option));
        optionsDiv.appendChild(label);
      });

      questionDiv.appendChild(optionsDiv);
      var feedbackDiv = document.createElement('div');
      feedbackDiv.classList.add('feedback');
      feedbackDiv.id = 'feedback-' + index;
      questionDiv.appendChild(feedbackDiv);

      var explanationDiv = document.createElement('div');
      explanationDiv.classList.add('explanation');
      explanationDiv.id = 'explanation-' + index;
      explanationDiv.style.display = 'none';
      // Ensure explanation includes reference as plain text initially, will be formatted by JS
      explanationDiv.innerHTML = '<strong>Correct Answer:</strong> ' + q.answer + '<br>' + q.explanation;
      questionDiv.appendChild(explanationDiv);
      
      quizContainer.appendChild(questionDiv);
    });
  }

  function checkAnswer(questionIndex, selectedOption) {
    var question = questions[questionIndex];
    var questionDiv = document.querySelectorAll('.question')[questionIndex]; 
    var optionsLabels = questionDiv.querySelectorAll('label'); 
    var feedbackDiv = document.getElementById('feedback-' + questionIndex);
    var explanationDiv = document.getElementById('explanation-' + questionIndex);
    var radios = document.getElementsByName('question' + questionIndex);

    // Disable all radio buttons for this question after an answer is selected
    radios.forEach(function(radio) { radio.disabled = true; });

    // Update background and border colors for selected and correct options
    optionsLabels.forEach(function(label) {
        var optionText = label.textContent.trim();
        if (optionText === selectedOption) {
            label.style.backgroundColor = selectedOption === question.answer ? '#d4edda' : '#ffe6e6'; // Light green for correct, light red for incorrect
            label.style.borderColor = selectedOption === question.answer ? '#28a745' : '#dc3545'; // Darker border for correct, darker red for incorrect
        }
        // Also highlight the correct answer if a wrong one was chosen
        if (optionText === question.answer && selectedOption !== question.answer) {
            label.style.backgroundColor = '#d4edda'; // Neutral green for correct answer if not selected
            label.style.borderColor = '#28a745';
        }
    });

    if (selectedOption === question.answer) {
      feedbackDiv.textContent = "Correct!";
      feedbackDiv.classList.remove('incorrect');
      feedbackDiv.classList.add('correct');
    } else {
      feedbackDiv.textContent = "Incorrect.";
      feedbackDiv.classList.remove('correct');
      feedbackDiv.classList.add('incorrect');
    }

    explanationDiv.style.display = 'block'; // Ensure explanation is always shown on click
  }

  // Timer functions
  function formatTime(seconds) {
    var minutes = Math.floor(seconds / 60);
    var remainingSeconds = seconds % 60;
    return minutes.toString().padStart(2, '0') + ':' + remainingSeconds.toString().padStart(2, '0');
  }

  function updateTimer() {
    timeLeft--;
    document.getElementById('timer-display').textContent = formatTime(timeLeft);

    var progressBar = document.getElementById('progress-bar');
    var progressPercentage = (timeLeft / totalQuizTime) * 100;
    progressBar.style.width = progressPercentage + '%';

    // Change color based on remaining time
    if (progressPercentage <= 25) {
      progressBar.classList.remove('warning');
      progressBar.classList.add('danger');
    } else if (progressPercentage <= 50) {
      progressBar.classList.remove('danger');
      progressBar.classList.add('warning');
    } else {
      progressBar.classList.remove('warning', 'danger');
    }

    if (timeLeft <= 0) {
      clearInterval(timerInterval);
      handleSubmit();
    }
  }

  function startTimer() {
    document.getElementById('timer-container').style.display = 'block';
    timerInterval = setInterval(updateTimer, 1000);
  }

  // Handle Submit
  function handleSubmit() {
    clearInterval(timerInterval); // Stop the timer
    document.getElementById('timer-container').style.display = 'none'; // Hide timer

    var score = 0;
    var totalQuestions = questions.length; // Get total questions from the 'questions' array

    questions.forEach(function(q, index) {
      var radios = document.getElementsByName('question' + index);
      var selectedValue = null;
      radios.forEach(function(radio) {
        radio.disabled = true; // Disable all options on submit
        if (radio.checked) {
          selectedValue = radio.value;
        }
      });

      // Show feedback and explanation for all questions
      var feedbackDiv = document.getElementById('feedback-' + index);
      var explanationDiv = document.getElementById('explanation-' + index);

      if (selectedValue === q.answer) {
        score++;
        feedbackDiv.textContent = "Correct!";
        feedbackDiv.classList.remove('incorrect');
        feedbackDiv.classList.add('correct');
      } else {
        feedbackDiv.textContent = "Incorrect.";
        feedbackDiv.classList.remove('correct');
        feedbackDiv.classList.add('incorrect');
      }
      // Ensure explanation is always shown on submit, and includes full correct answer text
      explanationDiv.innerHTML = '<strong>Correct Answer:</strong> ' + q.answer + '<br>' + q.explanation;
      explanationDiv.style.display = 'block'; 
    });

    // Display results
    var finalScoreElement = document.getElementById('final-score');
    var totalQuestionsDisplayElement = document.getElementById('total-questions-display');
    var passFailMessageElement = document.getElementById('pass-fail-message');
    var resultsOverlay = document.getElementById('results-overlay');

    finalScoreElement.textContent = score;
    totalQuestionsDisplayElement.textContent = totalQuestions; 

    var scorePercentage = (score / totalQuestions) * 100;
    if (scorePercentage >= (passingPercentage * 100)) {
      passFailMessageElement.textContent = 'Congratulations! You passed with ' + scorePercentage.toFixed(2) + '%.';
      passFailMessageElement.classList.remove('fail');
      passFailMessageElement.classList.add('pass');
    } else {
      passFailMessageElement.textContent = 'Keep studying! You scored ' + scorePercentage.toFixed(2) + '%, below the passing requirement.'
      passFailMessageElement.classList.remove('pass');
      passFailMessageElement.classList.add('fail');
    }

    resultsOverlay.style.display = 'flex'; // Show the results modal
    document.getElementById('submit-test-button').disabled = true; // Disable submit button after submission
  }

  // --- Page Flow Control ---
  document.addEventListener('DOMContentLoaded', () => {
    var welcomePage = document.getElementById('welcome-page');
    var quizContainer = document.getElementById('quiz-container');
    var quizTitle = document.getElementById('quiz-title');
    var startButton = document.getElementById('start-button');
    var submitTestButton = document.getElementById('submit-test-button');
    var timerContainer = document.getElementById('timer-container'); // Get timer container

    // Initial state: show welcome page
    welcomePage.style.display = 'flex';
    quizTitle.style.display = 'none';
    quizContainer.style.display = 'none';
    timerContainer.style.display = 'none'; // Ensure timer is hidden
    submitTestButton.style.display = 'none'; // Ensure submit button is hidden

    // Filter and shuffle questions once when the DOM is ready,
    // so 'questions' is populated before any click events rely on it.
    var mc = originalQuestions.filter(function(q) { return q.options.length > 2; });
    var tf = originalQuestions.filter(function(q) { return q.options.length === 2 && (q.options.includes("True") || q.options.includes("False")); });
    
    // Shuffle each group independently
    var shuffledMc = shuffleArray(mc);
    var shuffledTf = shuffleArray(tf);

    // Combine the shuffled groups to form the final 'questions' array
    questions = [...shuffledMc, ...shuffledTf];

    // Shuffle options for each question (except T/F)
    questions.forEach(function(q) {
        var isTrueFalseQuestion = q.options.length === 2 &&
                                  ((q.options[0] === "True" && q.options[1] === "False") ||
                                   (q.options[0] === "False" && q.options[1] === "True"));
        if (!isTrueFalseQuestion) {
            q.options = shuffleArray(q.options);
        }
    });

    // Event listener for "START" button on welcome page
    startButton.addEventListener('click', () => {
      welcomePage.style.display = 'none'; // Hide welcome page
      quizTitle.style.display = 'block';
      quizContainer.style.display = 'block';
      timerContainer.style.display = 'block'; // Show timer container
      submitTestButton.style.display = 'block'; // Show submit button

      initializeQuiz(); // Render the questions to the DOM
      startTimer(); // Start the timer
    });

    // Event listener for "Submit Test" button
    submitTestButton.addEventListener('click', handleSubmit);
  });
</script>
</body>
</html>
